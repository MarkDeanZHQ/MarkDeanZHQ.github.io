---
categories: [CS, Discrete]
tags: [CS, Discrete]
math: true
mermaid: true
render_with_liquid: true
img_path: 
description: 离散数学
pin: 
---
  
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [思维导图](#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE)
  - [命题与范式](#%E5%91%BD%E9%A2%98%E4%B8%8E%E8%8C%83%E5%BC%8F)
      - [1\. 一切的开始：从“砖头”到“句子”](#1%5C-%E4%B8%80%E5%88%87%E7%9A%84%E5%BC%80%E5%A7%8B%E4%BB%8E%E7%A0%96%E5%A4%B4%E5%88%B0%E5%8F%A5%E5%AD%90)
      - [2\. 分析主角的工具：真值表](#2%5C-%E5%88%86%E6%9E%90%E4%B8%BB%E8%A7%92%E7%9A%84%E5%B7%A5%E5%85%B7%E7%9C%9F%E5%80%BC%E8%A1%A8)
      - [3\. 两条主线：析取范式 (DNF) 与 合取范式 (CNF)](#3%5C-%E4%B8%A4%E6%9D%A1%E4%B8%BB%E7%BA%BF%E6%9E%90%E5%8F%96%E8%8C%83%E5%BC%8F-dnf-%E4%B8%8E-%E5%90%88%E5%8F%96%E8%8C%83%E5%BC%8F-cnf)
      - [4\. 补充说明](#4%5C-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E)
- [命题](#%E5%91%BD%E9%A2%98)
  - [联结词](#%E8%81%94%E7%BB%93%E8%AF%8D)
    - [优先级](#%E4%BC%98%E5%85%88%E7%BA%A7)
  - [基本等价关系](#%E5%9F%BA%E6%9C%AC%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB)
    - [逻辑电路简化](#%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%AE%80%E5%8C%96)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

  
# 思维导图

## 命题与范式
  
  
![范式与命题](https://raw.githubusercontent.com/MarkDeanZHQ/ImageHost/main/markdeanzhq.github.io/_posts/it/discrete/2025-08-04-离散小记.md/391270964334317.svg)
```puml
@startuml
' --- 设置样式，让图更好看 ---
skinparam object {
  BackgroundColor #F5F5F5
  ArrowColor #4A4A4A
  BorderColor #4A4A4A
}
skinparam note {
  BackgroundColor #FFFFE0
  BorderColor #BDB76B
  FontName "SimSun"
}
skinparam ArrowFontName "SimSun"

' --- 定义核心概念 ---
object "<b>命题变元 (p, q)</b>" as Var {
  最基本的砖头
  如：p 代表“今天下雨”
}

object "<b>文字 (Literal)</b>" as Literal {
  变元本身或其否定
  例如: p, ¬p
}
note left of Literal: “短语”在这一般叫“文字”。可以理解成带“正电”或“负电”的砖头。

object "<b>命题公式</b>" as Formula {
  用逻辑联结词(∧, ∨, ¬, →)组成的表达式
  如: p ∧ (q ∨ ¬p)
}

package "析取范式 (DNF) 分支" #LightSkyBlue {
  object "<b>极小项 (Minterm)</b>" as Minterm {
    所有变元都出现一次的“合取”式
    如: m₁ = ¬p ∧ q
  }
  note right of Minterm: 使公式为<b>真</b>的“原子条件”

  object "<b>主析取范式 (PDNF)</b>" as PDNF {
    所有<b>极小项</b>的“析取”
    唯一的，公式的“标准身份证”之一
  }

  object "<b>析取范式 (DNF)</b>" as DNF {
    (文字的合取) 的 析取
    形式: (A∧B) ∨ (C∧D)
  }
}

package "合取范式 (CNF) 分支" #LightGreen {
  object "<b>极大项 (Maxterm)</b>" as Maxterm {
    所有变元都出现一次的“析取”式
    如: M₁ = p ∨ ¬q
  }
  note left of Maxterm: 使公式为<b>假</b>的“原子条件”

  object "<b>主合取范式 (PCNF)</b>" as PCNF {
    所有<b>极大项</b>的“合取”
    唯一的，公式的“标准身份证”之二
  }

  object "<b>子句 (Clause) / 析取式</b>" as Clause {
     文字的“析取”
     如: (p ∨ ¬q)
  }
  object "<b>合取范式 (CNF)</b>" as CNF {
     <b>子句</b>的“合取”
     形式: (A∨B) ∧ (C∨D)
  }
}

object "<b>真值表技术</b>" as TruthTable {
  分析公式真假的核心工具
  每一行对应一个赋值
}

object "<b>编码</b>" as Encoding {
  变元赋值的二进制表示
  如: (p=0, q=1) -> 01
}


' --- 建立关系 (已修正语法) ---
Var --> Literal: "是构成...的基础"
Literal --> Formula: "通过 <b>合取(∧) / 析取(∨)</b> 等构成"
Var --> Formula

Formula <..> TruthTable: "是分析...的工具"

TruthTable --> Minterm: "<b>为真的行</b> 对应唯一的极小项"
TruthTable --> Maxterm: "<b>为假的行</b> 对应唯一的极大项"

Encoding <--> Minterm : "下标一一对应"
Encoding <--> Maxterm : "下标一一对应"

Minterm --> PDNF: "通过 <b>析取(∨)</b> 构成"
PDNF --|> DNF: "是一种特殊的..."

Maxterm --> PCNF: "通过 <b>合取(∧)</b> 构成"
PCNF --|> CNF: "是一种特殊的..."

' --- 【关键修正点】 ---
' 原来的错误写法被修正为标准的标签写法
Literal --> Clause : "通过 <b>析取(∨)</b> 构成"
Clause --> CNF : "通过 <b>合取(∧)</b> 构成"
' 为了逻辑更清晰，我把 DNF 的构成也拆解了一下
object "DNF的基本单元" as DNF_Unit {
  文字的“合取”
  如: (p ∧ ¬q)
}
Literal --> DNF_Unit : "通过 <b>合取(∧)</b> 构成"
DNF_Unit --> DNF : "通过 <b>析取(∨)</b> 构成"


' --- 连接范式和公式 ---
Formula <--> PDNF : "等价转换"
Formula <--> PCNF : "等价转换"
PDNF <--> PCNF : "互为对偶"

@enduml
```
  
  
#### 1\. 一切的开始：从“砖头”到“句子”

*   **命题变元 (Propositional Variable)**：这就是最最基础的“原子”或者说“砖头”，比如 `p`、`q`。它本身代表一个非真即假的简单陈述。
*   **文字 (Literal)**：这个概念很重要。你给的词里有“短语”，但在标准逻辑里，我们通常叫它“文字”。它就是一个变元或者这个变元的“否定”，比如 `p` 和 `¬p`。你可以把它想象成带正电（p）和带负电（¬p）的砖头，比单个的砖头多了一点信息。
*   **命-题公式 (Propositional Formula)**：把这些“文字”用“合取 (∧, AND)”和“析取 (∨, OR)”这些逻辑胶水粘起来，就成了一个完整的“句子”，也就是命题公式。它是我们整个故事的主角。

#### 2\. 分析主角的工具：真值表

*   **真值表技术 (Truth Table)**：这玩意儿就是个“照妖镜”。无论一个公式多复杂，把它扔进真值表，它在所有可能性（所有变元的真假组合）下的结果是真是假，都一目了然。这是我们后面所有操作的基础。

#### 3\. 两条主线：析取范式 (DNF) 与 合取范式 (CNF)

现在，故事分成两条线了，就像一个公式可以有两种不同的“标准照”。

**路线一：析取范式（DNF）—— 找“真”**

*   **极小项 (Minterm)**：你看真值表里，那些让整个公式结果为 **真 (True)** 的行。每一行都对应一个“极小项”。极小项是个“合取”式，包含了所有变量，并且能精确匹配那一行的真假赋值。比如 `(p=0, q=1)` 对应的极小项就是 `¬p ∧ q`。它就像是某个案件中，能让“真相大白”的唯一一种关键线索组合。
*   **主析取范式 (PDNF)**：把所有能让公式为“真”的极小项，用“析取 (∨)”连起来，就成了主析取范式。因为它是由所有“真”的情况构成的，所以它和原公式是等价的。这是公式的第一个“标准身份证”，全球唯一。
*   **析取范式 (DNF)**：PDNF是一种要求很严格的DNF。普通的DNF没那么严格，只要整体结构是“合取式的析取”，比如 `(p) ∨ (¬p ∧ q)`，就算。

**路线二：合取范式（CNF）—— 排除“假”**

*   **子句 (Clause)**：这是CNF的基本单元，它本身是一个“析取”式，比如 `(p ∨ ¬q)`。
*   **极大项 (Maxterm)**：对应地，你看真值表里那些让公式结果为 **假 (False)** 的行。每一行都对应一个“极大项”。极大项是个“析取”式，它也包含了所有变量，并且它的值在那一行恰好为假。比如 `(p=0, q=1)` 对应的极大项是 `p ∨ ¬q`。它就像是案件中，必须被排除的一种“错误可能性”。
*   **主合取范式 (PCNF)**：把所有能让公式为“假”的极大项，用“合取 (∧)”连起来，就成了主合取范式。它的逻辑是“不能是这种情况，**并且**也不能是那种情况……”，通过排除所有错误，剩下的自然就是正确的。这是公式的第二个“标准身份证”，同样全球唯一。
*   **合取范式 (CNF)**：PCNF是严格版的CNF。普通的CNF只要结构是“析取式的合取”（也就是一堆子句的合取）就行。

#### 4\. 补充说明

*   **编码 (Encoding)**：这很好理解。就是给变元的真假赋值（比如 p=T, q=F）一个二进制编号（10）。这个编号 `i` 正好对应极小项 `mᵢ` 和极大项 `Mᵢ` 的下标，让找它们变得非常方便。
*   **总结一下**：任何一个命题公式，都能被唯一地表示成它的主析取范式（所有“真”的可能性的总和）和主合取范式（排除所有“假”的可能性的结果）。而真值表，就是找到这些“真”和“假”的可能性的核心方法。


# 命题

## 联结词

### 优先级
$$\lnot\ >\ \land\ >\ \lor\ >\ \to\ >\ \leftrightarrow$$
![命题联结词优先级](https://raw.githubusercontent.com/MarkDeanZHQ/ImageHost/main/markdeanzhq.github.io/_posts/it/discrete/2025-08-04-1.md/120132666044773.png)


  
## 基本等价关系
![等价关系1](https://raw.githubusercontent.com/MarkDeanZHQ/ImageHost/main/markdeanzhq.github.io/_posts/it/discrete/2025-08-04-1.md/499373378342191.png)
  
  
![等价关系2](https://raw.githubusercontent.com/MarkDeanZHQ/ImageHost/main/markdeanzhq.github.io/_posts/it/discrete/2025-08-04-1.md/246825414794716.png)
  
  
![](https://raw.githubusercontent.com/MarkDeanZHQ/ImageHost/main/markdeanzhq.github.io/_posts/it/discrete/2025-08-04-1.md/573382402607959.png)  
  
### 逻辑电路简化
> 并联：$\lor$  
串联：$\land$

$$(\lnot G\lor H)\land(\lnot H\lor G)$$